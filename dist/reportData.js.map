{"version":3,"sources":["../src/reportData.js"],"names":["_","doRequext","GenericDatasource","ScrutinizerJSON","adhocFilters","console","log","authToken","reportType","startTime","endTime","ipAddress","reportDirection","expInterface","reportFilter","reportDisplay","exporterInterface","scrutFilters","scrutDisplay","sdfDips_0","filterJson","JSON","parse","key","hasOwnProperty","display","scrutInfo","url","method","params","rm","type","exporter","action","str","defaultGroupOnTop","statusTreeEnabled","page","scrutParams","report_data","reportDirections","selected","reportTypeLang","times","dateRange","start","end","clientTimezone","filters","dataGranularity","oneCollectorRequest","view","session_state","client_time_zone","order_by","search","column","value","comparison","data","filterType","_key","query_limit","offset","max_num_rows","hostDisplayType","rpt_json","stringify","orderBy","data_requested","graph","table","Handledata","rearrangeData","arr","oldIndex","newIndex","old_index","length","new_index","k","push","undefined","splice","scrutData","intervalTime","displayValue","datatoGraph","graphingData","i","j","graphData","tableData","Math","round","interfaceId","interfaceDesc","target","datapoints"],"mappings":"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","file":"reportData.js","sourcesContent":["import _ from \"lodash\";\r\nimport { doRequext, GenericDatasource } from \"./datasource\";\r\n\r\nexport class ScrutinizerJSON {\r\n  constructor() {}\r\n  createFilters (adhocFilters){\r\n    console.log(adhocFilters)\r\n\r\n    //check how many exporter filters are in a \r\n    //case for all interfaces \r\n\r\n    // case for single interface \r\n\r\n    // case for one device \r\n\r\n    // case for multiple devices \r\n\r\n    // case where source ip filter is added (or any filter)\r\n\r\n    // case for all devices \r\n  }\r\n  createParams(\r\n    authToken,\r\n    reportType,\r\n    startTime,\r\n    endTime,\r\n    ipAddress,\r\n    reportDirection,\r\n    expInterface,\r\n    reportFilter,\r\n    reportDisplay\r\n  ) {\r\n    let exporterInterface;\r\n    let scrutFilters;\r\n    let scrutDisplay;\r\n\r\n    if (expInterface === \"allInterfaces\") {\r\n      exporterInterface = \"_ALL\";\r\n    } else {\r\n      exporterInterface = expInterface;\r\n    }\r\n\r\n    //  if user wants all devices, then they are defualted to all interfaces\r\n    if (ipAddress === \"allExporters\") {\r\n      scrutFilters = {\r\n        sdfDips_0: `in_GROUP_ALL`\r\n      };\r\n    } else if (ipAddress === \"deviceGroup\") {\r\n      scrutFilters = {\r\n        sdfDips_0: `in_GROUP_${exporterInterface}`\r\n      };\r\n    } else {\r\n      // if user wants a specific device, they can either have ALL interfaces, or a specific interface\r\n      if (exporterInterface === \"_ALL\") {\r\n        scrutFilters = {\r\n          sdfDips_0: `in_${ipAddress}_ALL`\r\n        };\r\n      } else {\r\n        scrutFilters = {\r\n          sdfDips_0: `in_${ipAddress}_${ipAddress}-${exporterInterface}`\r\n        };\r\n      }\r\n    }\r\n    //if user is adding filters to the report.\r\n    if (reportFilter !== \"No Filter\") {\r\n      let filterJson = JSON.parse(reportFilter);\r\n      for (var key in filterJson) {\r\n        if (filterJson.hasOwnProperty(key)) {\r\n          if (key != \"sdfDips_0\") {\r\n            scrutFilters[key] = filterJson[key];\r\n          }\r\n        }\r\n      }\r\n    }\r\n    //percent vs bits check, these are passed into to the JSON for scrutinizer.\r\n    if (reportDisplay === \"percent\") {\r\n      scrutDisplay = { display: \"custom_interfacepercent\" };\r\n    } else {\r\n      scrutDisplay = { display: \"sum_octetdeltacount\" };\r\n    }\r\n\r\n    return {\r\n      authToken,\r\n      reportType,\r\n      startTime,\r\n      endTime,\r\n      ipAddress,\r\n      reportDirection,\r\n      expInterface: exporterInterface,\r\n      scrutFilters,\r\n      scrutDisplay\r\n    };\r\n  }\r\n\r\n\r\n\r\n\r\n  authJson(scrutInfo){\r\n    return {\r\n      url: scrutInfo['url'],\r\n      method: \"GET\",\r\n      params:{\r\n        rm: \"licensing\",\r\n        authToken:scrutInfo['authToken']\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  exporterJSON(scrutInfo) {\r\n    //params to figure out which exporters are available to pick from.\r\n    return {\r\n      url: scrutInfo['url'],\r\n      method: \"GET\",\r\n      params: {\r\n        rm: \"get_known_objects\",\r\n        type: \"devices\",\r\n        authToken: scrutInfo['authToken']\r\n      }\r\n    };\r\n  };\r\n\r\n  findExporter(scrutInfo, exporter) {\r\n    return {\r\n      url: scrutInfo[\"url\"],\r\n      method: \"GET\",\r\n      params: {\r\n        rm: \"loadMap\",\r\n        action: \"search\",\r\n        str: exporter,\r\n        authToken: scrutInfo[\"authToken\"],\r\n        defaultGroupOnTop: 1,\r\n        statusTreeEnabled: 1,\r\n        page: 1\r\n      }\r\n    };\r\n  };\r\n\r\n  findtimeJSON(scrutInfo,scrutParams) {\r\n    //params to figure out which interval your in based on data you are requesting\r\n    return {\r\n      url:scrutInfo['url'],\r\n      method:'get',\r\n      params:{\r\n        rm: \"report_start\",\r\n        authToken: scrutInfo['authToken'],\r\n        report_data: {\r\n          parse: true,\r\n          reportDirections: { selected: `${scrutParams.reportDirection}` },\r\n          reportTypeLang: `${scrutParams.reportType}`,\r\n          times: {\r\n            dateRange: \"Custom\",\r\n            start: `${scrutParams.startTime}`,\r\n            end: `${scrutParams.endTime}`,\r\n            clientTimezone: \"America/New_York\"\r\n          },\r\n          filters: scrutParams.scrutFilters,\r\n          dataGranularity: { selected: \"auto\" },\r\n          oneCollectorRequest: false\r\n        }\r\n      },\r\n\r\n    };\r\n  };\r\n\r\n  groupJSON(url, authToken) {\r\n    return {\r\n      url,\r\n      method: \"GET\",\r\n      params: {\r\n        rm: \"get_known_objects\",\r\n        type: \"deviceGroups\",\r\n        authToken\r\n      }\r\n    };\r\n  };\r\n\r\n  interfaceJSON(scrutInfo, ipAddress) {\r\n    //params to figure out which interfaces exist for a device\r\n    return {\r\n      url: scrutInfo[\"url\"],\r\n      method: \"get\",\r\n      params: {\r\n        rm: \"status\",\r\n        action: \"get\",\r\n        view: \"topInterfaces\",\r\n        authToken: scrutInfo[\"authToken\"],\r\n        session_state: {\r\n          client_time_zone: \"America/New_York\",\r\n          order_by: [],\r\n          search: [\r\n            {\r\n              column: \"exporter_search\",\r\n              value: `${ipAddress}`,\r\n              comparison: \"like\",\r\n              data: { filterType: \"multi_string\" },\r\n              _key: `exporter_search_like_${ipAddress}`\r\n            }\r\n          ],\r\n          query_limit: { offset: 0, max_num_rows: 50 },\r\n          hostDisplayType: \"dns\"\r\n        }\r\n      }\r\n    };\r\n  };\r\n\r\n  reportJSON(scrutInfo, scrutParams) {\r\n    //returning report params to be passed into request\r\n    return {\r\n      url:scrutInfo['url'],\r\n      'method':'get',\r\n      params:{\r\n        rm: \"report_api\",\r\n        action: \"get\",\r\n        authToken: scrutInfo['authToken'],\r\n        rpt_json: JSON.stringify({\r\n          reportTypeLang: scrutParams.reportType,\r\n          reportDirections: {\r\n            selected: scrutParams.reportDirection\r\n          },\r\n          times: {\r\n            dateRange: \"Custom\",\r\n            start: `${scrutParams.startTime}`,\r\n            end: `${scrutParams.endTime}`\r\n          },\r\n          orderBy: scrutParams.scrutDisplay[\"display\"],\r\n          filters: scrutParams.scrutFilters,\r\n          dataGranularity: {\r\n            selected: \"auto\"\r\n          }\r\n        }),\r\n  \r\n        data_requested: {\r\n          [scrutParams.reportDirection]: {\r\n            graph: \"all\",\r\n            table: {\r\n              query_limit: {\r\n                offset: 0,\r\n                max_num_rows: 10\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n    };\r\n  }  \r\n\r\n}\r\nexport class Handledata {\r\n  //scrutinizer returns graph data opposite of how grafana wants it. So we flip it here.\r\n  constructor() {\r\n    this.rearrangeData = (arr, oldIndex, newIndex) => {\r\n      while (oldIndex < 0) {\r\n        old_index += arr.length;\r\n      }\r\n      while (newIndex < 0) {\r\n        new_index += arr.length;\r\n      }\r\n      if (newIndex >= arr.length) {\r\n        let k = newIndex - arr.length;\r\n\r\n        while (k-- + 1) {\r\n          arr.push(undefined);\r\n        }\r\n      }\r\n      arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0]);\r\n      return arr;\r\n    };\r\n  }\r\n\r\n  formatData(scrutData, scrutParams, intervalTime) {\r\n    let displayValue;\r\n\r\n    if (scrutParams.scrutDisplay[\"display\"] === \"custom_interfacepercent\") {\r\n      displayValue = \"percent\";\r\n    } else {\r\n      displayValue = \"bits\";\r\n    }\r\n\r\n    let reportDirection = scrutParams.reportDirection;\r\n    //grafana wants time in millaseconds. so we multiple by 1000.\r\n    //we also want to return data in bits, so we device by 8\r\n    let datatoGraph = [];\r\n    let graphingData = scrutData;\r\n    let i,\r\n      j = 0;\r\n    let graphData = graphingData[\"report\"][\"graph\"][\"pie\"][reportDirection];\r\n    let tableData =\r\n      graphingData[\"report\"][\"graph\"][\"timeseries\"][reportDirection];\r\n    //if user is selecting bits, we need to multiple by 8, we also need to use the interval time.\r\n    if (displayValue === \"bits\") {\r\n      for (i = 0; i < tableData.length; i++) {\r\n        for (j = 0; j < tableData[i].length; j++) {\r\n          tableData[i][j][0] = tableData[i][j][0] * 1000;\r\n          tableData[i][j][1] = (tableData[i][j][1] * 8) / (intervalTime * 60);\r\n          this.rearrangeData(tableData[i][j], 0, 1);\r\n        }\r\n      }\r\n    } else {\r\n      //since interface reporting uses the total tables, we dont need to math it.\r\n      for (i = 0; i < tableData.length; i++) {\r\n        for (j = 0; j < tableData[i].length; j++) {\r\n          tableData[i][j][0] = tableData[i][j][0] * 1000;\r\n          tableData[i][j][1] = Math.round(tableData[i][j][1]);\r\n          this.rearrangeData(tableData[i][j], 0, 1);\r\n        }\r\n      }\r\n    }\r\n\r\n    for (i = 0; i < graphData.length; i++) {\r\n      let interfaceId;\r\n      let interfaceDesc;\r\n\r\n      if (scrutParams[\"reportType\"] === \"interfaces\") {\r\n        if (scrutParams[\"reportDirection\"] === \"inbound\") {\r\n          interfaceId = \"Inbound Interface\";\r\n          interfaceDesc = \"Inbound\";\r\n        } else {\r\n          interfaceId = \"Outbound Interface\";\r\n          interfaceDesc = \"Outbound\";\r\n        }\r\n        //scrutinizer returns a small amout of \"other traffic\" for interface reporting\r\n        //this has to do with the relationship between totals and conversations.\r\n        //we don't need this data, so we toss it out. It makes it do we can use SingleStat\r\n        //and Guage visualizations for interfaces, which is nice.\r\n        if (graphData[i][\"label\"] != \"Other\") {\r\n          datatoGraph.push({\r\n            target:\r\n              interfaceDesc + \"--\" + graphData[i][\"tooltip\"][1][interfaceId],\r\n            datapoints: tableData[i]\r\n          });\r\n        }\r\n      } else {\r\n        datatoGraph.push({\r\n          target: graphData[i][\"label\"],\r\n          datapoints: tableData[i]\r\n        });\r\n      }\r\n    }\r\n\r\n    return datatoGraph;\r\n  }\r\n}\r\n\r\n"]}