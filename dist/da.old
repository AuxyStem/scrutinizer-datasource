import _ from "lodash";
import {get_scrutinizer_data} from './reportData'
import {reportTypes} from './reportTypes'

let scrutinizerData = new get_scrutinizer_data


export class GenericDatasource {
  constructor(instanceSettings, $q, backendSrv, templateSrv, $http) {
    this.type = instanceSettings.type;
    this.url = instanceSettings.jsonData['scrutinizerURL'] + 'fcgi/scrut_fcgi.fcgi';
    this.authToken = instanceSettings.jsonData['scrutinizerKey']
    this.name = instanceSettings.name;
    this.q = $q;
    this.http = $http;
    this.backendSrv = backendSrv;
    this.templateSrv = templateSrv;
    this.reportOptions = reportTypes;
    this.withCredentials = instanceSettings.withCredentials;
    this.headers = { "Content-Type": "application/json" };
    if (
      typeof instanceSettings.basicAuth === "string" &&
      instanceSettings.basicAuth.length > 0
    ) {
      this.headers["Authorization"] = instanceSettings.basicAuth;
    }
    this.exporters = scrutinizerData.getExporters(this.url, this.authToken)
       
  }
    

  query(options) {
    console.log(this)

    
    var query = this.buildQueryParameters(options);

 
    query.targets = query.targets.filter(t => !t.hide);
    if (query.targets.length <= 0) {
      return this.q.when({ data: [] });
    }
    if (this.templateSrv.getAdhocFilters) {
      query.adhocFilters = this.templateSrv.getAdhocFilters(this.name);
    } else {
      query.adhocFilters = [];
    }
    let start_time = options['range']['from'].unix()
    let end_time = options['range']['to'].unix()
    let ip_address = query.targets[0].target
    let reportType = query.targets[0].reportType
    let datatoGraph = []


    let i = 0 
    for (i = 0 ; i < query.targets.length ; i ++){
      let ipAddress = query.targets[i].target;
      let reportType = query.targets[i].reportType;

    }
    
    
    return new Promise((resolve, reject) => {
      let data = scrutinizerData.getreportData(this.url, reportType,ip_address, this.authToken, start_time, end_time)
      
      data.then( (scrutData)=> {

          let graphingData = JSON.parse(scrutData.responseText)
          let i = 0
          let j = 0
          let data1 = graphingData["report"]["graph"]["pie"]["inbound"];
          let data2 = graphingData["report"]["graph"]["timeseries"]["inbound"];
          for (i=0; i < data2.length; i ++){
            for (j=0; j < (data2[i].length ); j++){
              
              data2[i][j][0] = data2[i][j][0] * 1000

              scrutinizerData.moveData(data2[i][j],0,1)
              
            }
            
          }
          

          for(i=0;i<data1.length;i++){


            datatoGraph.push({
                'target': data1[i]['label'],
                'datapoints':data2[i]
            })
            
          }
        
        },
        function(error) {
          console.log(error);
        }
      ).then((scrutinizer_data)=>{
        let result = { data : scrutinizer_data}
        return resolve(result)
      });
    });


  }

  testDatasource() {
    
    return this.doRequest({
      url: this.url + "/",
      method: "GET"
    }).then(response => {
      console.log(response)
      if (response.status === 200) {
        return {
          status: "success",
          message: "Data source is working",
          title: "Success"
        };
      }
    });
  }

  metricFindQuery(query) {
    return this.exporters;
  }

  mapToTextValue(result) {
    return _.map(result.data, (d, i) => {
      if (d && d.text && d.value) {
        return { text: d.text, value: d.value };
      } else if (_.isObject(d)) {
        return { text: d, value: i };
      }

      return { text: d, value: d };
    });
  }

  doRequest(options) {
    options.withCredentials = this.withCredentials;
    options.headers = this.headers;

    return this.backendSrv.datasourceRequest(options);
  }

  buildQueryParameters(options) {
    console.log(options)
    options.targets = _.filter(options.targets, target => {
      return target.target !== "select metric";
    });

    var targets = _.map(options.targets, target => {
      return {
        target: this.templateSrv.replace(
          target.target,
          options.scopedVars,
          "regex"
        ),
        refId: target.refId,
        hide: target.hide,
        type: target.type || "timeserie",

        reportType: this.templateSrv.replace(
          target.report,
          options.scopedVars,
          "regex"
        )
      };
    });

    options.targets = targets;

    return options;
  }

  getTagKeys(options) {
    return new Promise((resolve, reject) => {
      this.doRequest({
        url: this.url + "/tag-keys",
        method: "POST",
        data: options
      }).then(result => {
        return resolve(result.data);
      });
    });
  }

  getTagValues(options) {
    return new Promise((resolve, reject) => {
      this.doRequest({
        url: this.url + "/tag-values",
        method: "POST",
        data: options
      }).then(result => {
        return resolve(result.data);
      });
    });
  }
}
